# 语义化标记 + 工具函数架构示例

## 概述

本示例展示了如何使用 "语义化标记 + 工具函数" 架构构建符合主题样式的组件。该架构允许开发者通过简单的语义化标记定义组件样式，而无需直接编写复杂的 CSS 类名，同时确保所有组件在不同主题下保持视觉一致性。

## 核心概念

### 1. 语义化标记

语义化标记是一组直观的字符串，用于描述组件的样式特征。例如：
- `bg.surface` - 表面背景色
- `text.primary` - 主要文本色
- `border.default` - 默认边框样式
- `state.hover` - 悬停状态效果

### 2. 工具函数

- `s()` - 语义化样式生成器，将语义化标记转换为实际 CSS 类名
- `sx()` - 高级样式合并函数，支持语义化标记、条件样式和自定义样式
- `theme` - 主题样式工具函数集合
- `useComponentStyle()` - 组件样式 Hook，根据组件类型和变体自动生成样式

## 使用示例

### 1. 基础组件使用

```typescript
import { SemanticButton } from '@/components/semantic/SemanticButton';
import { SemanticCard, SemanticCardHeader, SemanticCardTitle } from '@/components/semantic/SemanticCard';
import { SemanticInput } from '@/components/semantic/SemanticInput';
import { SemanticSlider } from '@/components/semantic/SemanticSlider';
import { SemanticIcon } from '@/components/semantic/SemanticIcon';

// 语义化按钮
const ButtonExample = () => (
  <div className="space-x-4">
    <SemanticButton variant="primary" semantic={['state.hover', 'state.focus']}>
      主按钮
    </SemanticButton>
    <SemanticButton variant="secondary" size="small">
      次要按钮
    </SemanticButton>
    <SemanticButton variant="destructive" disabled>
      禁用按钮
    </SemanticButton>
  </div>
);

// 语义化卡片
const CardExample = () => (
  <SemanticCard semantic={['shadow.md', 'border.roundedLg']}>
    <SemanticCardHeader>
      <SemanticCardTitle>卡片标题</SemanticCardTitle>
      <p className="text-text-secondary">卡片描述内容</p>
    </SemanticCardHeader>
    <div className="p-6">
      <p>卡片内容区域</p>
    </div>
  </SemanticCard>
);

// 语义化输入框
const InputExample = () => (
  <SemanticInput 
    placeholder="请输入内容" 
    semantic={['state.focus', 'state.transition']}
    className="w-full max-w-md"
  />
);

// 语义化滑块
const SliderExample = () => (
  <div className="space-y-4">
    <div>
      <label className="block text-sm font-medium text-text-secondary mb-1">默认滑块</label>
      <SemanticSlider 
        min={0} 
        max={100} 
        defaultValue={50} 
        semantic={['state.focus', 'state.transition']}
        className="w-full"
      />
    </div>
    <div>
      <label className="block text-sm font-medium text-text-secondary mb-1">小型滑块</label>
      <SemanticSlider 
        min={0} 
        max={100} 
        defaultValue={30} 
        size="small"
        className="w-full"
      />
    </div>
    <div>
      <label className="block text-sm font-medium text-text-secondary mb-1">禁用滑块</label>
      <SemanticSlider 
        min={0} 
        max={100} 
        defaultValue={70} 
        disabled
        className="w-full"
      />
    </div>
  </div>
);

// 语义化图标
const IconExample = () => (
  <div className="space-x-6">
    <div className="flex flex-col items-center">
      <SemanticIcon name="Edit" size={24} />
      <span className="text-xs text-text-secondary mt-1">编辑图标</span>
    </div>
    <div className="flex flex-col items-center">
      <SemanticIcon name="Trash2" size={28} />
      <span className="text-xs text-text-secondary mt-1">删除图标</span>
    </div>
    <div className="flex flex-col items-center">
      <SemanticIcon name="Settings" size={20} />
      <span className="text-xs text-text-secondary mt-1">设置图标</span>
    </div>
    <div className="flex flex-col items-center">
      <SemanticIcon name="Info" size={32} />
      <span className="text-xs text-text-secondary mt-1">信息图标</span>
    </div>
  </div>
);
```

### 2. 在自定义组件中使用

```typescript
import React from 'react';
import { sx, s } from '@/themes/themeUtils';

interface CustomComponentProps {
  title: string;
  content: string;
  className?: string;
}

/**
 * 自定义组件示例
 * 使用语义化标记和工具函数实现主题样式
 */
export const CustomComponent: React.FC<CustomComponentProps> = ({ 
  title, 
  content, 
  className 
}) => {
  return (
    <div className={sx(['bg.surface', 'border.default', 'border.rounded', 'shadow.md'], undefined, className)}>
      <h3 className={sx(['text.text-primary', 'font-semibold', 'p-4', 'border-b border-border'])}>
        {title}
      </h3>
      <div className={sx(['p-4', 'text.text-secondary'])}>
        {content}
      </div>
      <div className={sx(['flex justify-end', 'p-4', 'border-t border-border'])}>
        <button 
          className={sx(['bg.accent', 'text.text-inverse', 'px-4', 'py-2', 'border.rounded', 'state.hover', 'state.focus'])}
        >
          操作按钮
        </button>
      </div>
    </div>
  );
};
```

### 3. 使用主题配置

```typescript
import { useCurrentTheme, theme } from '@/themes/themeUtils';

// 获取当前主题配置
const ThemeConfigExample = () => {
  const currentTheme = useCurrentTheme();
  
  return (
    <div className="bg-surface p-4 border border-border rounded-md">
      <h3 className="text-text-primary font-semibold mb-2">当前主题信息</h3>
      <div className="space-y-2 text-text-secondary">
        <p>主题名称: {currentTheme.name}</p>
        <p>主题ID: {currentTheme.id}</p>
        <p>是否深色主题: {currentTheme.isDark ? '是' : '否'}</p>
        <div className="flex items-center mt-2">
          <div 
            className="w-4 h-4 rounded-full mr-2"
            style={{ backgroundColor: currentTheme.colors.accent }}
          />
          <span>强调色: {currentTheme.colors.accent}</span>
        </div>
      </div>
    </div>
  );
};

// 使用主题工具函数
const ThemeUtilityExample = () => (
  <div className={theme.semantic(['bg.surface', 'p-4', 'border.rounded'])}>
    <h3 className={theme.semantic(['text.primary', 'font-semibold'])}>
      主题工具函数示例
    </h3>
    <p className={theme.semantic(['text.secondary', 'mt-2'])}>
      这是使用主题工具函数生成的文本样式
    </p>
  </div>
);
```

### 4. 条件样式

```typescript
import React, { useState } from 'react';
import { sx } from '@/themes/themeUtils';

const ConditionalStyleExample = () => {
  const [isActive, setIsActive] = useState(false);
  
  return (
    <div className="space-y-4">
      {/* 条件语义化样式 */}
      <div 
        className={sx(
          ['bg.surface', 'border.default', 'p-4', 'border.rounded'],
          {
            'bg.accent text.text-inverse': isActive,
            'border.accent': isActive
          }
        )}
      >
        条件样式示例
      </div>
      
      {/* 切换按钮 */}
      <button 
        className={sx(['bg.surface', 'border.default', 'px-4', 'py-2', 'border.rounded', 'state.hover'])}
        onClick={() => setIsActive(!isActive)}
      >
        {isActive ? '取消激活' : '激活'}
      </button>
    </div>
  );
};
```

### 5. 组件样式 Hook

```typescript
import React from 'react';
import { useComponentStyle } from '@/themes/themeUtils';

interface CustomButtonProps {
  variant?: 'primary' | 'secondary';
  size?: 'small' | 'medium';
  children: React.ReactNode;
}

const CustomButton: React.FC<CustomButtonProps> = ({ 
  variant = 'primary', 
  size = 'medium', 
  children 
}) => {
  // 使用组件样式 Hook
  const buttonStyle = useComponentStyle({
    component: 'button',
    variant,
    size,
    customClasses: 'state.hover state.focus'
  });
  
  return (
    <button className={buttonStyle}>
      {children}
    </button>
  );
};
```

## 架构优势

### 1. 主题一致性

所有组件使用统一的主题变量，确保在不同主题下保持视觉一致性。

### 2. 开发效率

开发者可以通过简单的语义化标记定义组件样式，无需记忆复杂的 CSS 类名，提高开发效率。

### 3. 可维护性

主题样式集中管理，修改主题配置即可改变所有组件的样式，降低维护成本。

### 4. 扩展性

新组件可以轻松集成到架构中，无需重新设计样式系统。

### 5. 类型安全

提供 TypeScript 类型支持，减少开发错误。

## 主题配置

主题配置位于 `src/themes/` 目录下，包含以下文件：
- `modernDarkTheme.ts` - 现代深色主题配置
- `modernLightTheme.ts` - 现代浅色主题配置
- `themeManager.ts` - 主题管理器，负责主题切换和持久化
- `themeUtils.ts` - 主题工具函数
- `types.ts` - 主题类型定义

修改主题配置文件即可改变所有组件的样式，无需修改组件代码。

## 最佳实践

1. **优先使用语义化标记**：尽量使用语义化标记定义组件样式，避免直接编写 CSS 类名
2. **合理使用条件样式**：根据组件状态动态调整样式
3. **保持组件简洁**：每个组件只负责单一功能，样式通过语义化标记定义
4. **使用组件样式 Hook**：对于复杂组件，使用 `useComponentStyle()` Hook 生成样式
5. **避免硬编码颜色**：始终使用主题变量，不直接使用硬编码颜色值

## 总结

"语义化标记 + 工具函数" 架构提供了一种高效、可维护的方式来构建符合主题样式的组件。通过这种架构，开发者可以专注于组件的功能实现，而无需担心样式的一致性问题。主题配置的集中管理也使得主题切换和样式调整变得更加简单。