# 设计文档

## 概述

AmberPipeline 是一款创新的 AI 驱动游戏资产制作工具，旨在简化从原始图像到可用游戏资产的转换流程。本设计文档详细描述了系统的架构、组件、数据模型以及与竞品的对比分析。

## 架构

### 整体架构

AmberPipeline 采用前后端分离的架构，前端使用 Electron 构建跨平台桌面应用，后端使用 FastAPI 提供 AI 模型推理服务。

```
┌─────────────────────────────────────────────────────────────┐
│                        前端 (Electron)                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │  UI 组件层  │  │  状态管理   │  │   Canvas 渲染层     │ │
│  │  (React 19) │  │  (Zustand)  │  │  (多 Stage 系统)    │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
│         │                │                     │             │
│         └────────────────┴─────────────────────┘             │
│                          │                                   │
│                  ┌───────▼────────┐                          │
│                  │   API 客户端   │                          │
│                  └───────┬────────┘                          │
└──────────────────────────┼──────────────────────────────────┘
                           │ HTTP/WebSocket
┌──────────────────────────▼──────────────────────────────────┐
│                      后端 (FastAPI)                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │  API 路由   │  │  业务逻辑   │  │   AI 模型服务       │ │
│  │             │  │             │  │   (SAM 2.1)         │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
│         │                │                     │             │
│         └────────────────┴─────────────────────┘             │
│                          │                                   │
│                  ┌───────▼────────┐                          │
│                  │  文件系统管理  │                          │
│                  └────────────────┘                          │
└─────────────────────────────────────────────────────────────┘
```

### 前端架构

前端采用模块化设计，主要分为以下几个层次：

1. **应用层 (App Layer)**：应用入口、路由管理、全局配置
2. **模块层 (Module Layer)**：功能模块（Canvas、Header、Task、Properties）
3. **组件层 (Component Layer)**：可复用的 UI 组件
4. **服务层 (Service Layer)**：API 调用、数据处理
5. **状态层 (State Layer)**：全局状态管理（Zustand）
6. **主题层 (Theme Layer)**：主题系统、样式管理

### 后端架构

后端采用分层架构：

1. **API 层**：处理 HTTP 请求，参数验证
2. **服务层**：业务逻辑处理
3. **模型层**：AI 模型推理（SAM 2.1）
4. **数据层**：文件系统操作、元数据管理

## 组件和接口

### 核心组件

#### 1. MainCanvas 组件

主画布组件，负责图像显示和交互。

**接口**：
```typescript
interface MainCanvasProps {
  tabs: Tab[];
  activeTabId: string;
  currentMode: 'precision-cut' | 'character-layer' | 'skeleton-binding' | 'animation';
  onTabCreate?: () => void;
  onTabClose?: (tabId: string) => void;
  onTabSelect?: (tabId: string) => void;
  onImport?: () => void;
  onProcessingChange?: (isProcessing: boolean) => void;
  className?: string;
}
```

**功能**：
- 多标签页管理
- 画布缩放、平移、旋转
- 工具选择和切换
- 图层渲染和交互

#### 2. RenderDispatcher 组件

渲染调度器，根据当前 Stage 动态渲染对应的图层。

**接口**：
```typescript
interface RenderDispatcherProps {
  mode: 'precision-cut' | 'character-layer' | 'skeleton-binding' | 'animation';
  data: any;
  transform: {
    scale: number;
    translateX: number;
    translateY: number;
  };
  onProcessingChange?: (isProcessing: boolean) => void;
}
```

**功能**：
- Stage A：背景图层、分割遮罩层、Inpainting 预览层
- Stage B：部位图层、语义标记层、边缘吸附层
- Stage C：骨骼图层、权重热力图层、IK 链可视化层
- Stage D：动画预览层、洋葱皮层、时间轴层

#### 3. SmartPanel 组件

智能属性面板，根据当前 Stage 和选中对象动态显示属性。

**接口**：
```typescript
interface SmartPanelProps {
  stage: 'A' | 'B' | 'C' | 'D';
  selectedObject?: any;
  onPropertyChange?: (property: string, value: any) => void;
}
```

**功能**：
- Stage A：层级管理器、Inpaint 设置、导出选项
- Stage B：部位预设、图层细分属性、自动网格化
- Stage C：骨骼层级树、权重编辑、约束设置
- Stage D：动画剪辑管理、关键帧插值、导出设置

#### 4. LeftToolbar 组件

左侧工具栏，提供工具选择和快捷操作。

**接口**：
```typescript
interface LeftToolbarProps {
  currentStage: 'A' | 'B' | 'C' | 'D';
  activeTool: string;
  onToolSelect: (toolId: string) => void;
}
```

**功能**：
- 工具图标和快捷键显示
- 工具分组（按 Stage）
- 工具状态指示

#### 5. BottomPanel 组件

底部面板，显示任务状态或动画时间轴。

**接口**：
```typescript
interface BottomPanelProps {
  stage: 'A' | 'B' | 'C' | 'D';
  tasks?: Task[];
  timeline?: Timeline;
  onTaskClick?: (taskId: string) => void;
  onTimelineChange?: (time: number) => void;
}
```

**功能**：
- Stage A-C：任务列表、进度显示、日志输出
- Stage D：时间轴、关键帧编辑、播放控制

### API 接口

#### 1. 图像分割 API

```
POST /segment
Content-Type: multipart/form-data

Request:
- image: File (图像文件)
- points: Array<{x: number, y: number, label: 0|1}> (点提示)

Response:
{
  "masks": Array<{
    "mask": string (Base64 编码的遮罩图像),
    "score": number (置信度分数)
  }>,
  "inference_time": number (推理时间，毫秒)
}
```

#### 2. 法线贴图生成 API

```
POST /generate-normal-map
Content-Type: multipart/form-data

Request:
- image: File (图像文件)
- strength: number (强度，0-1)

Response:
{
  "normal_map": string (Base64 编码的法线贴图),
  "processing_time": number (处理时间，毫秒)
}
```

#### 3. 模型状态 API

```
GET /model/status

Response:
{
  "is_loaded": boolean,
  "model_name": string,
  "device": "cpu" | "cuda" | "mps",
  "memory_usage": number (MB)
}
```

## 数据模型

### 项目数据模型

```typescript
interface Project {
  id: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
  tabs: Tab[];
  activeTabId: string;
}

interface Tab {
  id: string;
  title: string;
  mode: 'precision-cut' | 'character-layer' | 'skeleton-binding' | 'animation';
  content: TabContent;
}

interface TabContent {
  // Stage A 数据
  precisionCut?: {
    originalImage: string;
    layers: Layer[];
    inpaintSettings: InpaintSettings;
  };
  
  // Stage B 数据
  characterLayer?: {
    parts: Part[];
    presets: string;
    meshSettings: MeshSettings;
  };
  
  // Stage C 数据
  skeletonBinding?: {
    bones: Bone[];
    weights: WeightMap;
    constraints: Constraint[];
  };
  
  // Stage D 数据
  animation?: {
    clips: AnimationClip[];
    timeline: Timeline;
    onionSkinSettings: OnionSkinSettings;
  };
}
```

### 图层数据模型

```typescript
interface Layer {
  id: string;
  name: string;
  type: 'image' | 'mask' | 'bone' | 'animation';
  visible: boolean;
  locked: boolean;
  opacity: number;
  zIndex: number;
  transform: Transform;
  data: any;
}

interface Transform {
  x: number;
  y: number;
  scaleX: number;
  scaleY: number;
  rotation: number;
}
```

### 骨骼数据模型

```typescript
interface Bone {
  id: string;
  name: string;
  parentId: string | null;
  position: { x: number; y: number };
  rotation: number;
  length: number;
  constraints: {
    minRotation?: number;
    maxRotation?: number;
  };
}

interface WeightMap {
  [boneId: string]: {
    [vertexId: string]: number; // 权重值 0-1
  };
}

interface Constraint {
  id: string;
  type: 'IK' | 'rotation_limit';
  boneIds: string[];
  parameters: any;
}
```

### 动画数据模型

```typescript
interface AnimationClip {
  id: string;
  name: string;
  duration: number;
  fps: number;
  loop: boolean;
  keyframes: Keyframe[];
}

interface Keyframe {
  time: number;
  boneId: string;
  transform: {
    position?: { x: number; y: number };
    rotation?: number;
  };
  easing: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'bezier';
}

interface Timeline {
  currentTime: number;
  duration: number;
  fps: number;
  markers: TimelineMarker[];
}

interface TimelineMarker {
  time: number;
  label: string;
  color: string;
}
```

## 竞品分析

### 主要竞品对比

| 特性 | AmberPipeline | Photoshop | Spine | Live2D Cubism | DragonBones |
|------|---------------|-----------|-------|---------------|-------------|
| **AI 驱动分割** | ✅ SAM 2.1 | ❌ 手动 | ❌ | ❌ | ❌ |
| **自动 Inpainting** | ✅ | ⚠️ 需插件 | ❌ | ❌ | ❌ |
| **语义部位拆解** | ✅ | ❌ | ❌ | ⚠️ 手动 | ❌ |
| **骨骼绑定** | ✅ | ❌ | ✅ | ✅ | ✅ |
| **IK/FK 混合** | ✅ | ❌ | ✅ | ⚠️ 有限 | ✅ |
| **动画制作** | ✅ | ⚠️ 时间轴 | ✅ | ✅ | ✅ |
| **实时预览** | ✅ | ⚠️ 有限 | ✅ | ✅ | ✅ |
| **多格式导出** | ✅ | ✅ | ✅ | ✅ | ✅ |
| **跨平台** | ✅ | ✅ | ✅ | ✅ | ✅ |
| **价格** | 免费/开源 | 订阅制 | 付费 | 付费 | 免费 |
| **学习曲线** | 低 | 高 | 中 | 中 | 中 |
| **游戏引擎集成** | ✅ | ❌ | ✅ | ✅ | ✅ |

### 详细竞品分析

#### 1. Adobe Photoshop

**优势**：
- 强大的图像编辑功能
- 丰富的插件生态
- 行业标准工具

**劣势**：
- 不专注于游戏资产制作
- 缺乏 AI 驱动的自动化功能
- 没有骨骼绑定和动画功能
- 价格昂贵（订阅制）

**AmberPipeline 的差异化**：
- 提供 AI 驱动的自动分割和 Inpainting
- 集成完整的游戏资产制作流程
- 免费开源

#### 2. Spine

**优势**：
- 专业的 2D 骨骼动画工具
- 强大的动画编辑功能
- 广泛的游戏引擎支持

**劣势**：
- 需要手动准备资产（分割、裁剪）
- 没有 AI 辅助功能
- 价格较高（$69-$329）
- 学习曲线较陡

**AmberPipeline 的差异化**：
- 提供从原图到动画的完整流程
- AI 驱动的自动化处理
- 更低的学习门槛
- 免费开源

#### 3. Live2D Cubism

**优势**：
- 专注于 2D 角色动画
- 独特的网格变形技术
- 高质量的动画效果

**劣势**：
- 需要手动准备多层资产
- 学习曲线较陡
- 价格较高（$42-$2,520）
- 主要面向日式动画风格

**AmberPipeline 的差异化**：
- AI 驱动的自动部位拆解
- 更通用的动画风格支持
- 更简单的工作流
- 免费开源

#### 4. DragonBones

**优势**：
- 免费开源
- 支持多种游戏引擎
- 简单易用

**劣势**：
- 功能相对简单
- 缺乏高级动画功能
- 社区支持有限
- 开发不够活跃

**AmberPipeline 的差异化**：
- 提供完整的资产制作流程
- AI 驱动的自动化功能
- 更现代的技术栈
- 更活跃的开发

### 市场定位

AmberPipeline 定位于**AI 驱动的游戏资产制作中间件**，填补了从原始图像到可用游戏资产之间的空白。

**目标用户**：
1. **独立游戏开发者**：需要快速制作游戏资产，但缺乏专业美术技能
2. **游戏美术设计师**：希望提高工作效率，减少重复性劳动
3. **小型游戏工作室**：需要降低资产制作成本，加快开发速度
4. **游戏原型开发者**：需要快速验证游戏创意，制作原型

**核心价值主张**：
1. **AI 驱动的自动化**：大幅减少手动操作，提高效率
2. **完整的工作流**：从原图到动画的一站式解决方案
3. **低学习门槛**：直观的界面和智能的辅助功能
4. **免费开源**：降低使用成本，促进社区发展

## 正确性属性

*属性是一种特征或行为，应该在系统的所有有效执行中保持为真——本质上是关于系统应该做什么的正式陈述。属性作为人类可读规范和机器可验证正确性保证之间的桥梁。*

### 属性 1：图像分割一致性

*对于任何*有效的输入图像和点提示，SAM 模型应该生成至少一个有效的分割遮罩，且遮罩的尺寸应与输入图像一致。

**验证：需求 1.2**

### 属性 2：图层 Z-index 唯一性

*对于任何*图层集合，每个图层的 Z-index 值应该是唯一的，且调整 Z-index 后图层的渲染顺序应该正确反映深度关系。

**验证：需求 2.1, 2.2**

### 属性 3：部位拆解完整性

*对于任何*角色图像，使用语义涂抹工具标记的所有部位应该被正确分割为独立图层，且所有像素应该被分配到某个部位（无遗漏）。

**验证：需求 3.1, 3.3**

### 属性 4：骨骼层级一致性

*对于任何*骨骼系统，每个骨骼（除根骨骼外）应该有且仅有一个父骨骼，且不存在循环依赖。

**验证：需求 4.4**

### 属性 5：权重归一化

*对于任何*网格顶点，所有骨骼对该顶点的权重之和应该等于 1.0（误差在 0.001 以内）。

**验证：需求 5.5**

### 属性 6：IK 链有效性

*对于任何*IK 链，起始关节和末端关节之间应该存在有效的骨骼路径，且 IK 求解应该在合理的迭代次数内收敛。

**验证：需求 6.1, 6.2**

### 属性 7：关键帧插值连续性

*对于任何*两个相邻的关键帧，插值计算的中间帧应该在时间和空间上连续，不应出现突变。

**验证：需求 7.2**

### 属性 8：标签页状态隔离

*对于任何*标签页，切换到其他标签页再切换回来后，该标签页的状态（图层、工具、设置等）应该与切换前完全一致。

**验证：需求 8.2**

### 属性 9：撤销重做对称性

*对于任何*操作序列，执行撤销后再执行重做应该恢复到撤销前的状态（撤销-重做往返一致性）。

**验证：需求 13.2, 13.3**

### 属性 10：文件导入导出往返一致性

*对于任何*项目，保存为文件后再加载，加载后的项目数据应该与保存前完全一致（除了时间戳等元数据）。

**验证：需求 12.5, 12.6**

## 错误处理

### 错误类型

1. **用户输入错误**：
   - 无效的文件格式
   - 超出范围的参数值
   - 不合法的操作序列

2. **系统错误**：
   - 内存不足
   - GPU 不可用
   - 文件系统错误

3. **网络错误**：
   - API 请求失败
   - 超时
   - 连接中断

4. **模型错误**：
   - 模型加载失败
   - 推理错误
   - 结果无效

### 错误处理策略

1. **优雅降级**：
   - GPU 不可用时自动切换到 CPU
   - 模型加载失败时提供手动工具
   - 网络错误时使用本地缓存

2. **用户友好的错误提示**：
   - 清晰的错误信息
   - 可操作的解决建议
   - 错误日志记录

3. **自动恢复**：
   - 自动保存工作进度
   - 崩溃后自动恢复
   - 网络重连后自动重试

4. **错误边界**：
   - React 错误边界捕获组件错误
   - 全局错误处理器捕获未处理的异常
   - 进程间通信错误隔离

## 测试策略

### 双重测试方法

本项目采用**单元测试**和**基于属性的测试**相结合的方法，以确保全面的测试覆盖。

#### 单元测试

单元测试用于验证特定示例、边缘情况和错误条件：

- **特定示例**：测试已知输入和预期输出
- **边缘情况**：测试边界值、空输入、极端值
- **错误条件**：测试错误处理和异常情况
- **集成点**：测试组件之间的交互

**示例**：
```typescript
// 测试图层 Z-index 调整
test('adjusting layer z-index updates render order', () => {
  const layers = [
    { id: '1', zIndex: 0 },
    { id: '2', zIndex: 1 },
    { id: '3', zIndex: 2 }
  ];
  
  adjustLayerZIndex(layers, '3', 0);
  
  expect(layers[0].id).toBe('3');
  expect(layers[0].zIndex).toBe(0);
});
```

#### 基于属性的测试

基于属性的测试用于验证通用属性在所有输入下都成立：

- **通用属性**：验证系统的不变量
- **随机输入**：通过随机生成的输入测试
- **全面覆盖**：测试大量输入组合

**配置**：
- 每个属性测试至少运行 **100 次迭代**
- 使用 **fast-check** 库进行属性测试
- 每个测试必须引用设计文档中的属性

**标签格式**：
```typescript
// Feature: product-documentation, Property 5: 权重归一化
test('weight normalization property', () => {
  fc.assert(
    fc.property(
      fc.array(fc.float({ min: 0, max: 1 })),
      (weights) => {
        const normalized = normalizeWeights(weights);
        const sum = normalized.reduce((a, b) => a + b, 0);
        expect(Math.abs(sum - 1.0)).toBeLessThan(0.001);
      }
    ),
    { numRuns: 100 }
  );
});
```

### 测试覆盖目标

- **代码覆盖率**：至少 80%
- **分支覆盖率**：至少 70%
- **关键路径覆盖率**：100%

### 测试工具

- **单元测试**：Jest + React Testing Library
- **基于属性的测试**：fast-check
- **端到端测试**：Playwright
- **性能测试**：Lighthouse + Custom Metrics
