# 需求文档

## 简介

AmberPipeline 是一款专注于 AI 原图到游戏资产转换的中间件工具，为设计师提供从图像分割到角色骨架绑定的完整工作流解决方案。本产品旨在简化游戏资产制作流程，提高设计师的工作效率，降低技术门槛。

## 术语表

- **System**: AmberPipeline 应用系统
- **User**: 使用 AmberPipeline 的游戏设计师或美术人员
- **SAM_Model**: Segment Anything Model，用于图像分割的 AI 模型
- **Canvas**: 画布，用户进行图像编辑的主要工作区域
- **Stage**: 工作流阶段，包括 Stage A（精确裁剪）、Stage B（角色图层）、Stage C（骨架绑定）、Stage D（动画制作）
- **Layer**: 图层，图像的独立可编辑层级
- **Bone**: 骨骼，用于角色动画的骨架结构
- **Weight**: 权重，骨骼对网格顶点的影响程度
- **IK**: Inverse Kinematics，反向运动学
- **FK**: Forward Kinematics，正向运动学
- **Mask**: 遮罩，用于选择图像的特定区域
- **Inpainting**: 图像修复，填充移除对象后的空白区域
- **Keyframe**: 关键帧，动画中的重要时间点

## 需求

### 需求 1：精确裁剪功能

**用户故事**：作为游戏美术设计师，我想要使用 AI 驱动的图像分割功能，以便快速准确地从复杂背景中提取游戏资产。

#### 验收标准

1. WHEN 用户上传一张图像 THEN THE System SHALL 在画布中显示该图像
2. WHEN 用户在图像上点击一个点 THEN THE SAM_Model SHALL 生成候选分割遮罩
3. WHEN 用户选择一个遮罩 THEN THE System SHALL 允许用户编辑和优化该遮罩
4. WHEN 用户确认遮罩 THEN THE System SHALL 将选中区域提取为独立图层
5. WHEN 用户移除背景对象 THEN THE System SHALL 提供实时 Inpainting 功能填充空白区域
6. WHEN 用户调整 Inpainting 参数 THEN THE System SHALL 实时更新修复效果预览
7. WHEN 用户完成精确裁剪 THEN THE System SHALL 支持导出为 PNG 或 PSD 格式

### 需求 2：深度层级管理

**用户故事**：作为游戏美术设计师，我想要为分割后的对象分配深度信息，以便在游戏中实现正确的前后遮挡关系。

#### 验收标准

1. WHEN 用户选择一个图层 THEN THE System SHALL 允许用户为其分配 Z-index 值
2. WHEN 用户调整 Z-index THEN THE System SHALL 实时更新图层的前后顺序预览
3. WHEN 用户拖拽图层 THEN THE System SHALL 支持通过拖拽调整图层顺序
4. WHEN 用户查看图层列表 THEN THE System SHALL 显示所有图层及其深度关系
5. WHEN 用户隐藏或锁定图层 THEN THE System SHALL 相应地更新画布显示和编辑权限

### 需求 3：角色部位拆解

**用户故事**：作为游戏美术设计师，我想要将角色图像拆分为独立的身体部位，以便为后续的骨骼绑定和动画制作做准备。

#### 验收标准

1. WHEN 用户选择语义涂抹工具 THEN THE System SHALL 提供不同颜色的笔刷标记不同部位
2. WHEN 用户涂抹部位边缘 THEN THE SAM_Model SHALL 辅助修正笔刷边缘以确保精确分割
3. WHEN 用户完成部位标记 THEN THE System SHALL 自动生成独立的部位图层
4. WHEN 用户选择关节补全功能 THEN THE System SHALL 在分割处自动生成圆滑的重叠像素
5. WHEN 用户应用部位预设 THEN THE System SHALL 提供标准人形或动物模板快速分割
6. WHEN 用户调整边缘羽化参数 THEN THE System SHALL 实时更新部位边缘的平滑度
7. WHEN 用户设置扩张像素 THEN THE System SHALL 在关节点处添加像素冗余以覆盖旋转空隙

### 需求 4：骨骼绘制与编辑

**用户故事**：作为游戏美术设计师，我想要为角色创建骨骼系统，以便实现角色的动画控制。

#### 验收标准

1. WHEN 用户点击画布 THEN THE System SHALL 创建骨骼关节点
2. WHEN 用户拖动关节点 THEN THE System SHALL 生成连接两个关节点的骨骼
3. WHEN 用户选择骨骼 THEN THE System SHALL 显示该骨骼的属性和控制选项
4. WHEN 用户编辑骨骼层级 THEN THE System SHALL 支持设置骨骼的父子关系
5. WHEN 用户设置镜像对称 THEN THE System SHALL 自动创建对称的骨骼结构
6. WHEN 用户删除骨骼 THEN THE System SHALL 同时删除相关的子骨骼和权重数据

### 需求 5：权重绘制与可视化

**用户故事**：作为游戏美术设计师，我想要为骨骼分配权重，以便控制骨骼对角色网格的影响范围。

#### 验收标准

1. WHEN 用户选择骨骼 THEN THE System SHALL 以热力图形式显示该骨骼的权重分布
2. WHEN 用户使用权重画笔 THEN THE System SHALL 允许用户手动绘制权重
3. WHEN 用户调整画笔强度 THEN THE System SHALL 相应地改变权重绘制的影响程度
4. WHEN 用户选择自动权重计算 THEN THE System SHALL 基于重心算法自动分配权重
5. WHEN 用户归一化权重 THEN THE System SHALL 确保每个顶点的总权重为 1.0
6. WHEN 用户平滑权重 THEN THE System SHALL 对权重分布进行平滑处理以避免变形瑕疵

### 需求 6：IK/FK 混合控制

**用户故事**：作为游戏美术设计师，我想要使用 IK 和 FK 控制方式，以便灵活地调整角色姿态。

#### 验收标准

1. WHEN 用户选择起始和末端关节 THEN THE System SHALL 生成 IK 链约束
2. WHEN 用户拖动 IK 目标 THEN THE System SHALL 自动计算并更新骨骼链的旋转
3. WHEN 用户旋转骨骼 THEN THE System SHALL 支持 FK 模式直接控制骨骼旋转
4. WHEN 用户设置旋转限制 THEN THE System SHALL 防止关节超出合理的旋转范围
5. WHEN 用户切换 IK/FK 模式 THEN THE System SHALL 保持当前姿态不变

### 需求 7：动画关键帧系统

**用户故事**：作为游戏美术设计师，我想要创建角色动画，以便为游戏提供动态的角色表现。

#### 验收标准

1. WHEN 用户调整角色姿态 THEN THE System SHALL 允许用户在当前时间点记录关键帧
2. WHEN 用户在时间轴上移动 THEN THE System SHALL 自动插值计算中间帧的姿态
3. WHEN 用户启用洋葱皮预览 THEN THE System SHALL 显示前后若干帧的幻影效果
4. WHEN 用户创建动画剪辑 THEN THE System SHALL 支持命名和管理多个动画片段
5. WHEN 用户设置循环播放 THEN THE System SHALL 在动画结束后自动回到起始帧
6. WHEN 用户调整帧率 THEN THE System SHALL 相应地改变动画播放速度
7. WHEN 用户选择插值类型 THEN THE System SHALL 支持线性和贝塞尔曲线插值

### 需求 8：多标签页工作流

**用户故事**：作为游戏美术设计师，我想要同时处理多个项目，以便提高工作效率。

#### 验收标准

1. WHEN 用户点击新建标签页 THEN THE System SHALL 创建一个新的空白画布
2. WHEN 用户切换标签页 THEN THE System SHALL 保存当前标签页的状态并加载目标标签页
3. WHEN 用户关闭标签页 THEN THE System SHALL 提示用户保存未保存的更改
4. WHEN 用户拖拽标签页 THEN THE System SHALL 支持重新排列标签页顺序
5. WHEN 用户在标签页之间复制图层 THEN THE System SHALL 支持跨标签页的图层操作

### 需求 9：实时系统监控

**用户故事**：作为游戏美术设计师，我想要查看系统性能信息，以便了解当前的资源使用情况。

#### 验收标准

1. WHEN 用户查看状态栏 THEN THE System SHALL 显示当前的 GPU 使用率
2. WHEN 用户查看状态栏 THEN THE System SHALL 显示当前的 VRAM 使用量
3. WHEN 用户查看状态栏 THEN THE System SHALL 显示当前的帧率 (FPS)
4. WHEN 系统资源不足 THEN THE System SHALL 显示警告提示
5. WHEN 用户点击系统信息 THEN THE System SHALL 显示详细的硬件和模型信息

### 需求 10：国际化支持

**用户故事**：作为游戏美术设计师，我想要使用我熟悉的语言，以便更好地理解和使用工具。

#### 验收标准

1. WHEN 用户首次启动应用 THEN THE System SHALL 根据系统语言自动选择界面语言
2. WHEN 用户切换语言 THEN THE System SHALL 立即更新所有界面文本
3. THE System SHALL 支持中文、英文和日语三种语言
4. WHEN 用户查看工具提示 THEN THE System SHALL 以当前选择的语言显示提示信息
5. WHEN 用户导出文件 THEN THE System SHALL 使用当前语言生成文件名和元数据

### 需求 11：主题系统

**用户故事**：作为游戏美术设计师，我想要选择适合我工作环境的主题，以便减少视觉疲劳。

#### 验收标准

1. THE System SHALL 提供亮色和暗色两种主题
2. WHEN 用户切换主题 THEN THE System SHALL 立即应用新主题到所有界面元素
3. WHEN 用户选择跟随系统主题 THEN THE System SHALL 根据操作系统的主题设置自动切换
4. WHEN 用户重启应用 THEN THE System SHALL 保持上次选择的主题设置

### 需求 12：文件导入导出

**用户故事**：作为游戏美术设计师，我想要导入和导出各种格式的文件，以便与其他工具和引擎集成。

#### 验收标准

1. WHEN 用户导入图像 THEN THE System SHALL 支持 PNG、JPG、PSD 等常见格式
2. WHEN 用户导出精确裁剪结果 THEN THE System SHALL 支持导出为多层 PSD 或独立 PNG 序列
3. WHEN 用户导出骨骼数据 THEN THE System SHALL 支持导出为 JSON 格式
4. WHEN 用户导出动画 THEN THE System SHALL 支持导出为 GIF、MP4 或 Spine 格式
5. WHEN 用户保存项目 THEN THE System SHALL 将所有数据保存为项目文件
6. WHEN 用户加载项目 THEN THE System SHALL 恢复所有图层、骨骼和动画数据

### 需求 13：撤销重做系统

**用户故事**：作为游戏美术设计师，我想要撤销和重做操作，以便在出错时快速恢复。

#### 验收标准

1. WHEN 用户执行操作 THEN THE System SHALL 将操作记录到历史栈
2. WHEN 用户点击撤销 THEN THE System SHALL 恢复到上一个状态
3. WHEN 用户点击重做 THEN THE System SHALL 前进到下一个状态
4. WHEN 用户在历史中间执行新操作 THEN THE System SHALL 清除后续的重做历史
5. THE System SHALL 支持至少 50 步的撤销历史
6. WHEN 用户使用快捷键 Ctrl+Z THEN THE System SHALL 执行撤销操作
7. WHEN 用户使用快捷键 Ctrl+Y THEN THE System SHALL 执行重做操作

### 需求 14：快捷键系统

**用户故事**：作为游戏美术设计师，我想要使用快捷键，以便提高操作效率。

#### 验收标准

1. THE System SHALL 为常用工具提供快捷键
2. WHEN 用户按下快捷键 THEN THE System SHALL 激活对应的工具或功能
3. WHEN 用户查看快捷键列表 THEN THE System SHALL 显示所有可用的快捷键
4. WHEN 用户自定义快捷键 THEN THE System SHALL 允许用户修改快捷键绑定
5. WHEN 快捷键冲突 THEN THE System SHALL 提示用户并阻止设置

### 需求 15：性能优化

**用户故事**：作为游戏美术设计师，我想要流畅的操作体验，以便高效地完成工作。

#### 验收标准

1. WHEN 用户缩放画布 THEN THE System SHALL 在 16ms 内完成渲染以保持 60 FPS
2. WHEN 用户处理大尺寸图像 THEN THE System SHALL 使用离屏渲染优化性能
3. WHEN 用户切换图层 THEN THE System SHALL 在 100ms 内完成切换
4. WHEN 用户使用 SAM 模型 THEN THE System SHALL 在 GPU 上运行推理以加速处理
5. WHEN 系统内存不足 THEN THE System SHALL 自动清理缓存以释放内存
